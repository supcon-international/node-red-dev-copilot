<!-- Dev Copilot Node Configuration Panel -->
<script type="text/javascript">
  RED.nodes.registerType("dev-copilot", {
    category: "AI dev copilot",
    color: "#87CEEB",
    defaults: {
      name: { value: "" },
      provider: { value: "openai", required: true },
      model: { value: "gpt-4.1", required: true },
      temperature: {
        value: 0.1,
        required: true,
        validate: RED.validators.number(),
      },
      maxTokens: {
        value: 2000,
        required: true,
        validate: RED.validators.number(),
      },
      toolCallLimit: {
        value: 10,
        required: true,
        validate: RED.validators.number(),
      },
      mcpCommand: {
        value: "npx @supcon-international/node-red-mcp-server",
      },
      mcpArgs: { value: "" },
      mcpEnv: { value: "" },
      systemPrompt: { value: "" },
    },
    credentials: {
      apiKey: { type: "password", required: true },
    },
    inputs: 1,
    outputs: 1,
    icon: "font-awesome/fa-robot",
    label: function () {
      return this.name || `${this.provider} ${this.model}`;
    },
    labelStyle: function () {
      return this.name ? "node_label_italic" : "";
    },
    paletteLabel: "dev copilot",
    oneditprepare: function () {
      const providerPlaceholders = {
        openai: "e.g.: gpt-4, gpt-4-turbo, gpt-3.5-turbo, gpt-4o, gpt-4o-mini",
        google: "e.g.: gemini-2.5-pro, gemini-2.5-flash",
        deepseek: "e.g.: deepseek-chat, deepseek-reasoner",
      };

      function updateModelPlaceholder() {
        const provider = $("#node-input-provider").val();
        const modelInput = $("#node-input-model");

        if (providerPlaceholders[provider]) {
          modelInput.attr("placeholder", providerPlaceholders[provider]);
        }
      }

      // Update model placeholder when provider changes
      $("#node-input-provider").on("change", function () {
        updateModelPlaceholder();
      });

      // Initialize
      updateModelPlaceholder();
    },
  });
</script>

<!-- Node editing panel template -->
<script type="text/html" data-template-name="dev-copilot">
  <div class="form-row">
    <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name" />
  </div>

  <div class="form-row">
    <label for="node-input-provider"
      ><i class="fa fa-cloud"></i> Provider</label
    >
    <select id="node-input-provider">
      <option value="openai">OpenAI</option>
      <option value="google">Google</option>
      <option value="deepseek">DeepSeek</option>
    </select>
  </div>

  <div class="form-row">
    <label for="node-input-model"><i class="fa fa-cog"></i> Model</label>
    <input
      type="text"
      id="node-input-model"
      placeholder="e.g.: gpt-4, gpt-4-turbo, gpt-3.5-turbo, gpt-4o, gpt-4o-mini"
    />
    <div class="form-tips">
      Enter the model name you want to use. Recommended models will be shown
      based on the Provider.
    </div>
  </div>

  <div class="form-row">
    <label for="node-input-temperature"
      ><i class="fa fa-thermometer-half"></i> Temperature</label
    >
    <input
      type="number"
      id="node-input-temperature"
      placeholder="0.1"
      min="0"
      max="2"
      step="0.1"
      style="width: 100px;"
    />
    <div class="form-tips">
      Controls randomness (0.0 = deterministic, 2.0 = very creative). For coding
      tasks, use 0.0-0.3.
    </div>
  </div>

  <div class="form-row">
    <label for="node-input-maxTokens"
      ><i class="fa fa-file-text-o"></i> Max Tokens</label
    >
    <input
      type="number"
      id="node-input-maxTokens"
      placeholder="2000"
      min="100"
      step="100"
      style="width: 100px;"
    />
    <div class="form-tips">
      Maximum response length. For coding: 1000-2000 for snippets, 3000-4000 for
      complex solutions.
    </div>
  </div>

  <div class="form-row">
    <label for="node-input-toolCallLimit"
      ><i class="fa fa-repeat"></i> Tool Call Limit</label
    >
    <input
      type="number"
      id="node-input-toolCallLimit"
      placeholder="10"
      min="1"
      step="1"
      style="width: 100px;"
    />
    <div class="form-tips">
      Maximum rounds of tool calls to prevent infinite loops. For complex tasks,
      use 8-15. For simple tasks, use 3-5.
    </div>
  </div>

  <div class="form-row">
    <label for="node-input-apiKey"><i class="fa fa-key"></i> API Key</label>
    <input type="password" id="node-input-apiKey" data-nr-credentials="true" />
  </div>

  <div class="form-row">
    <label for="node-input-mcpCommand"
      ><i class="fa fa-terminal"></i> MCP Command</label
    >
    <input
      type="text"
      id="node-input-mcpCommand"
      placeholder="e.g.: npx @supcon-international/node-red-mcp-server"
    />
    <div class="form-tips">
      MCP server startup command (leave empty to not use MCP)
    </div>
  </div>

  <div class="form-row">
    <label for="node-input-mcpArgs"><i class="fa fa-list"></i> Arguments</label>
    <input
      type="text"
      id="node-input-mcpArgs"
      placeholder="e.g.: --port 3000 --verbose"
    />
    <div class="form-tips">
      Optional: command line arguments, separated by spaces
    </div>
  </div>

  <div class="form-row">
    <label for="node-input-mcpEnv"
      ><i class="fa fa-gear"></i> Environment Variables</label
    >
    <input
      type="text"
      id="node-input-mcpEnv"
      placeholder="e.g.: API_KEY=xxx,DEBUG=true"
    />
    <div class="form-tips">
      Optional: environment variables, format: KEY=value, multiple separated by
      commas
    </div>
  </div>

  <div class="form-row">
    <label for="node-input-systemPrompt"
      ><i class="fa fa-comment"></i> System Prompt</label
    >
    <textarea
      id="node-input-systemPrompt"
      rows="4"
      placeholder="You are a helpful Node-RED development assistant."
    ></textarea>
  </div>
</script>

<!-- Node help documentation -->
<script type="text/html" data-help-name="dev-copilot">
  <p>AI Development Copilot node with MCP (Model Context Protocol) support.</p>

  <h3>Configuration</h3>
  <dl class="message-properties">
    <dt>Provider <span class="property-type">string</span></dt>
    <dd>The AI provider to use (OpenAI, Google, DeepSeek)</dd>

    <dt>Model <span class="property-type">string</span></dt>
    <dd>The specific model to use (e.g., gpt-4, gemini-1.5-pro)</dd>

    <dt>Temperature <span class="property-type">number</span></dt>
    <dd>
      Controls randomness (0.0 = deterministic, 2.0 = very creative). For coding
      tasks, recommended range: 0.0-0.3
    </dd>

    <dt>Max Tokens <span class="property-type">number</span></dt>
    <dd>
      Maximum response length. For coding: 1000-2000 for snippets, 3000-4000 for
      complex solutions
    </dd>

    <dt>Tool Call Limit <span class="property-type">number</span></dt>
    <dd>
      Maximum rounds of tool calls to prevent infinite loops. For complex
      multi-step tasks, use 8-15. For simple tasks, use 3-5.
    </dd>

    <dt>API Key <span class="property-type">credentials</span></dt>
    <dd>API key for the selected provider</dd>

    <dt>MCP Server Path <span class="property-type">string</span></dt>
    <dd>Path to the MCP server executable (optional)</dd>

    <dt>MCP Server Args <span class="property-type">string</span></dt>
    <dd>Arguments to pass to the MCP server (optional)</dd>

    <dt>System Prompt <span class="property-type">string</span></dt>
    <dd>System prompt to use for AI interactions</dd>
  </dl>

  <h3>Input</h3>
  <dl class="message-properties">
    <dt>payload <span class="property-type">string | object</span></dt>
    <dd>The user message or query to send to the AI</dd>

    <dt>history <span class="property-type">array</span></dt>
    <dd>Optional conversation history array</dd>
  </dl>

  <h3>Output</h3>
  <dl class="message-properties">
    <dt>payload <span class="property-type">string</span></dt>
    <dd>The AI's response</dd>

    <dt>llm_config <span class="property-type">object</span></dt>
    <dd>Configuration used for this request</dd>

    <dt>mcp_available <span class="property-type">boolean</span></dt>
    <dd>Whether MCP tools are available</dd>

    <dt>mcp_tools <span class="property-type">array</span></dt>
    <dd>Available MCP tools (if MCP is connected)</dd>
  </dl>

  <h3>Details</h3>
  <p>
    This node provides AI assistance for development tasks. It can optionally
    connect to MCP (Model Context Protocol) servers to extend functionality with
    additional tools and resources.
  </p>

  <p>
    The node also registers a sidebar interface for interactive chat
    functionality.
  </p>
</script>

<!-- Sidebar registration script -->
<script type="text/javascript">
  (function () {
    let sidebarRegistered = false;

    function registerDevCopilotSidebar() {
      if (sidebarRegistered) {
        return;
      }

      try {
        // Check if RED object is available
        if (!RED || !RED.sidebar) {
          setTimeout(registerDevCopilotSidebar, 500);
          return;
        }

        // Register sidebar tab
        RED.sidebar.addTab({
          id: "dev-copilot-sidebar",
          label: "Dev Copilot",
          name: "Dev Copilot",
          iconClass: "fa fa-rocket",
          content: $('<div id="dev-copilot-content"></div>'),
          toolbar: $('<div id="dev-copilot-toolbar"></div>'),
          enableOnEdit: true,
          onchange: function () {
            loadSidebarContent();
          },
        });

        sidebarRegistered = true;

        // Load content immediately
        loadSidebarContent();
      } catch (error) {
        console.error("Failed to register Dev Copilot sidebar:", error);
        // If failed, retry later
        setTimeout(registerDevCopilotSidebar, 1000);
      }
    }

    // Wait for DOM and RED to fully load
    $(document).ready(function () {
      // Delay registration to ensure RED is fully loaded
      setTimeout(registerDevCopilotSidebar, 100);
    });

    // Listen for runtime events as backup
    if (RED && RED.events) {
      RED.events.on("runtime-event", function (event) {
        if (
          event.id === "runtime-state" &&
          event.payload.state === "start" &&
          !sidebarRegistered
        ) {
          registerDevCopilotSidebar();
        }
      });
    }

    function loadSidebarContent() {
      const content = $("#dev-copilot-content");
      if (content.length === 0) {
        setTimeout(loadSidebarContent, 500);
        return;
      }

      // Load sidebar content
      $.get("/dev-copilot/sidebar")
        .done(function (data) {
          content.html(data);
          initializeSidebarFunctionality();
        })
        .fail(function (xhr, status, error) {
          console.error("Failed to load Dev Copilot sidebar:", {
            status: xhr.status,
            statusText: xhr.statusText,
            error: error,
          });

          let errorMsg = "Failed to load Dev Copilot sidebar";
          if (xhr.status) {
            errorMsg += " (HTTP " + xhr.status + ")";
          }
          if (error) {
            errorMsg += ": " + error;
          }

          content.html(
            '<div class="red-ui-info-outline"><p>' +
              errorMsg +
              "</p><p>Check browser console for more details.</p></div>"
          );
        });
    }

    function initializeSidebarFunctionality() {
      // Initialize sidebar functionality
      const messageContainer = $("#dev-copilot-messages");
      const messageInput = $("#dev-copilot-input");
      const sendButton = $("#dev-copilot-send");
      const nodeSelect = $("#dev-copilot-node-select");
      const clearButton = $("#dev-copilot-clear");

      let messageHistory = [];
      let currentNodeId = null;

      // Message persistence functionality - Using Node-RED context storage (localfilesystem) instead of localStorage
      const GLOBAL_MESSAGES_CONTEXT_KEY = "dev-copilot-global-messages"; // Global shared message history Key in global.json
      const SELECTED_NODE_CONTEXT_KEY = "dev-copilot-selected-node";

      // Context storage helper functions
      async function getContextData(key, nodeId = null) {
        try {
          const response = await $.ajax({
            url: "/dev-copilot/context/get",
            method: "POST",
            contentType: "application/json",
            data: JSON.stringify({ key, nodeId }),
          });
          return response.success ? response.data : null;
        } catch (error) {
          console.warn("Failed to get context data:", error);
          return null;
        }
      }

      async function setContextData(key, data, nodeId = null) {
        try {
          const response = await $.ajax({
            url: "/dev-copilot/context/set",
            method: "POST",
            contentType: "application/json",
            data: JSON.stringify({ key, data, nodeId }),
          });
          return response.success;
        } catch (error) {
          console.warn("Failed to set context data:", error);
          return false;
        }
      }

      async function deleteContextData(key, nodeId = null) {
        try {
          const response = await $.ajax({
            url: "/dev-copilot/context/delete",
            method: "POST",
            contentType: "application/json",
            data: JSON.stringify({ key, nodeId }),
          });
          return response.success;
        } catch (error) {
          console.warn("Failed to delete context data:", error);
          return false;
        }
      }

      // Load global shared message history from Node-RED context storage
      async function loadMessageHistory() {
        try {
          const stored = await getContextData(GLOBAL_MESSAGES_CONTEXT_KEY);

          if (stored && Array.isArray(stored)) {
            return stored;
          }
        } catch (error) {
          console.warn("Failed to load message history:", error);
        }
        return [];
      }

      // Save global shared message history to Node-RED context storage
      async function saveMessageHistory(history) {
        if (!Array.isArray(history)) return false;

        try {
          // Limit history length to avoid context storage becoming too large

          const success = await setContextData(
            GLOBAL_MESSAGES_CONTEXT_KEY,
            history
          );
          return success;
        } catch (error) {
          console.warn("Failed to save message history:", error);
          return false;
        }
      }

      // Restore messages to UI
      function restoreMessagesToUI(history) {
        messageContainer.empty();

        if (history.length === 0) {
          // Show empty state prompt
          messageContainer.html(
            '<div class="dev-copilot-empty-state">Select a Dev Copilot node and start chatting!<br><small>Ask about Node-RED development questions.</small></div>'
          );
          return;
        }

        history.forEach((msg) => {
          if (msg.role === "user") {
            addMessageToUI("user", msg.content);
          } else if (msg.role === "assistant") {
            addMessageToUI("assistant", msg.content);
          }
        });
      }

      // Add message and persist to global shared storage
      async function addMessageAndSave(role, content) {
        messageHistory.push({ role, content });

        // Save immediately to global shared Node-RED context storage
        await saveMessageHistory(messageHistory);
      }

      // Save selected node ID to Node-RED context storage
      async function saveSelectedNode(nodeId) {
        try {
          const success = await setContextData(
            SELECTED_NODE_CONTEXT_KEY,
            nodeId
          );
          return success;
        } catch (error) {
          console.warn("Failed to save selected node:", error);
          return false;
        }
      }

      // Load last selected node ID from Node-RED context storage
      async function loadSelectedNode() {
        try {
          const nodeId = await getContextData(SELECTED_NODE_CONTEXT_KEY);
          return nodeId;
        } catch (error) {
          console.warn("Failed to load selected node:", error);
          return null;
        }
      }

      // Clear global shared history
      async function clearGlobalHistory() {
        if (
          confirm(
            "Are you sure you want to clear all global chat history? This will affect all nodes and cannot be undone."
          )
        ) {
          messageHistory = [];
          messageContainer.empty();
          messageContainer.html(
            '<div class="dev-copilot-empty-state">Chat history cleared<br><small>Start a new conversation!</small></div>'
          );

          // Remove from Node-RED context storage
          const success = await deleteContextData(GLOBAL_MESSAGES_CONTEXT_KEY);
          RED.notify(
            "Global chat history cleared",
            success ? "success" : "error"
          );
        }
      }

      // Load available nodes
      loadAvailableNodes();

      // Send message
      function sendMessage() {
        const currentState = $("#dev-copilot-send").attr("data-state");

        if (currentState === "generating") {
          // User wants to stop generation
          if (currentAbortController) {
            currentAbortController.abort();
            currentAbortController = null;
          }

          setSendButtonState("ready");
          // Note: The actual stop handling is done in the catch blocks of
          // sendStreamingMessage and sendTraditionalMessage functions
          return;
        }

        // Normal send message flow
        const message = messageInput.val().trim();
        if (!message) {
          addMessageToUI("error", "Please enter message content");
          return;
        }

        // Check if a node is selected
        if (!currentNodeId) {
          addMessageToUI(
            "error",
            "Please select a Dev Copilot node first. If no nodes are available, please create and configure nodes in the canvas first."
          );
          return;
        }

        // Check if streaming mode is enabled
        const streamModeEnabled = $("#dev-copilot-stream-toggle").is(
          ":checked"
        );

        // Add user message to interface and save
        addMessageToUI("user", message);
        addMessageAndSave("user", message); // Use new save function (async)

        // Clear input box
        messageInput.val("");

        // Set button to generating state
        setSendButtonState("generating");

        if (streamModeEnabled) {
          // Use streaming mode
          sendStreamingMessage(message);
        } else {
          // Use traditional mode
          sendTraditionalMessage(message);
        }
      }

      // Traditional non-streaming message sending
      function sendTraditionalMessage(message) {
        // Show loading state
        const loadingMessage = addMessageToUI("assistant", "ü§ñ Thinking...", {
          isLoading: true,
        });

        // Create abort controller for cancellation
        currentAbortController = new AbortController();

        // Send request
        $.ajax({
          url: "/dev-copilot/chat",
          method: "POST",
          contentType: "application/json",
          data: JSON.stringify({
            message: message,
            nodeId: currentNodeId,
            history: messageHistory, // Keep all history messages for API call
          }),
          xhr: function () {
            const xhr = new window.XMLHttpRequest();

            // Handle abort signal
            currentAbortController.signal.addEventListener("abort", () => {
              xhr.abort();
            });

            return xhr;
          },
          success: function (response) {
            // Check if request was aborted
            if (currentAbortController?.signal.aborted) {
              return;
            }

            // Remove loading message
            loadingMessage.remove();

            // Reset button state
            setSendButtonState("ready");
            currentAbortController = null;

            if (response.success) {
              addMessageToUI("assistant", response.response);
              addMessageAndSave("assistant", response.response); // Save AI response (async)
            } else {
              addMessageToUI("error", "Error: " + response.error);
            }
          },
          error: function (xhr) {
            // Check if request was aborted
            if (currentAbortController?.signal.aborted) {
              // User stopped the request - handle gracefully
              loadingMessage.remove();
              addMessageToUI("warning", "Response generation stopped by user.");
              setSendButtonState("ready");
              currentAbortController = null;
              return;
            }

            // Remove loading message
            loadingMessage.remove();

            // Reset button state
            setSendButtonState("ready");
            currentAbortController = null;

            let errorMsg = "Network error";
            try {
              const errorResponse = JSON.parse(xhr.responseText);
              errorMsg = errorResponse.error || errorMsg;
            } catch (e) {
              errorMsg = xhr.responseText || errorMsg;
            }

            addMessageToUI("error", errorMsg);
          },
        });
      }

      // Streaming message sending
      async function sendStreamingMessage(message) {
        let accumulatedContent = "";
        let currentMessageElement = null;

        // Create a new assistant message container for streaming
        currentMessageElement = addMessageToUI("assistant", "ü§ñ Starting...", {
          isStreaming: true,
        });

        // Create abort controller for cancellation
        currentAbortController = new AbortController();

        try {
          // Use fetch API for streaming SSE
          const response = await fetch("/dev-copilot/chat-stream", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              message: message,
              nodeId: currentNodeId,
              history: messageHistory,
            }),
            signal: currentAbortController.signal,
          });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          // Read the stream
          const reader = response.body.getReader();
          const decoder = new TextDecoder();

          while (true) {
            const { value, done } = await reader.read();

            if (done) {
              break;
            }

            // Check if aborted
            if (currentAbortController.signal.aborted) {
              break;
            }

            // Decode the chunk
            const chunk = decoder.decode(value, { stream: true });

            // Process SSE data
            const lines = chunk.split("\n");
            for (const line of lines) {
              if (line.startsWith("data: ")) {
                const dataStr = line.substring(6).trim();
                if (dataStr) {
                  try {
                    const data = JSON.parse(dataStr);
                    handleStreamChunk(data);
                  } catch (e) {
                    console.warn("Failed to parse SSE data:", dataStr);
                  }
                }
              }
            }
          }

          // Final save and cleanup
          if (!currentAbortController.signal.aborted) {
            if (accumulatedContent) {
              addMessageAndSave("assistant", accumulatedContent);
            }

            finishStreamingMessage(currentMessageElement);
            setSendButtonState("ready");
          }
        } catch (error) {
          if (error.name === "AbortError") {
            // Request was aborted by user - preserve generated content
            if (currentMessageElement && accumulatedContent.trim()) {
              // Add stop indicator to existing content
              const stoppedContent =
                accumulatedContent + "\n\n‚ö†Ô∏è Generation stopped by user";
              updateMessageContent(currentMessageElement, stoppedContent);
              finishStreamingMessage(currentMessageElement);

              // Save the partial content
              addMessageAndSave("assistant", accumulatedContent);
            } else if (currentMessageElement) {
              // No content generated, remove the empty message
              currentMessageElement.remove();
              addMessageToUI("warning", "Response generation stopped by user.");
            }
            setSendButtonState("ready");
            return;
          }

          console.error("Stream request failed:", error);

          // Remove the streaming message element
          if (currentMessageElement) {
            currentMessageElement.remove();
          }

          // Show error
          addMessageToUI("error", `Streaming failed: ${error.message}`);
          setSendButtonState("ready");
        } finally {
          currentAbortController = null;
        }

        // Handle individual stream chunks
        function handleStreamChunk(data) {
          switch (data.type) {
            case "start":
              updateMessageContent(currentMessageElement, "ü§ñ Starting...");
              break;

            case "content":
              accumulatedContent += data.content;
              updateMessageContent(currentMessageElement, accumulatedContent);
              break;

            case "tool":
              if (accumulatedContent.trim()) {
                accumulatedContent += "\n\n" + data.content + "\n";
              } else {
                accumulatedContent += data.content + "\n";
              }
              updateMessageContent(currentMessageElement, accumulatedContent);
              break;

            case "info":
            case "warning":
              if (accumulatedContent.trim()) {
                accumulatedContent += "\n\n" + data.content;
              } else {
                accumulatedContent += data.content;
              }
              updateMessageContent(currentMessageElement, accumulatedContent);
              break;

            case "error":
              if (accumulatedContent.trim()) {
                accumulatedContent += "\n\n‚ùå " + data.content;
              } else {
                accumulatedContent += "‚ùå " + data.content;
              }
              updateMessageContent(currentMessageElement, accumulatedContent);
              break;

            case "end":
              // Stream completed - will be handled in main try block
              break;

            default:
              console.warn("Unknown stream chunk type:", data.type);
          }
        }
      }

      // Send button state management
      let currentAbortController = null;

      function setSendButtonState(state) {
        const sendButton = $("#dev-copilot-send");
        const sendIcon = sendButton.find(".send-icon");
        const sendText = sendButton.find(".send-text");
        const messageInput = $("#dev-copilot-input");

        // Remove all state classes
        sendButton.removeClass("generating");
        sendButton.attr("data-state", state);

        switch (state) {
          case "ready":
            sendIcon.text("‚ñ∂");
            sendText.text("Send");
            sendButton.prop("disabled", false);
            messageInput.prop("disabled", false);
            break;

          case "generating":
            sendIcon.text("‚èπ");
            sendText.text("Stop");
            sendButton.addClass("generating");
            sendButton.prop("disabled", false);
            messageInput.prop("disabled", true);
            break;

          case "disabled":
            sendIcon.text("‚ñ∂");
            sendText.text("Send");
            sendButton.prop("disabled", true);
            messageInput.prop("disabled", true);
            break;
        }
      }

      // Unified message UI function
      function addMessageToUI(type, content, options = {}) {
        const { isLoading = false, isStreaming = false } = options;

        // Create message element with proper classes
        const messageClasses = ["dev-copilot-message", type];
        if (isLoading) messageClasses.push("loading");
        if (isStreaming) messageClasses.push("streaming");

        const messageDiv = $(`<div class="${messageClasses.join(" ")}"></div>`);

        // Set content
        messageDiv.text(content);

        // Append and scroll
        messageContainer.append(messageDiv);
        messageContainer.scrollTop(messageContainer[0].scrollHeight);

        return messageDiv;
      }

      // Update message content (for streaming)
      function updateMessageContent(messageElement, content) {
        if (messageElement) {
          messageElement.text(content);
          messageContainer.scrollTop(messageContainer[0].scrollHeight);
        }
      }

      // Remove streaming indicator when complete
      function finishStreamingMessage(messageElement) {
        if (messageElement) {
          messageElement.removeClass("streaming");
        }
      }

      // Load available nodes
      function loadAvailableNodes() {
        $.get("/dev-copilot/nodes", function (nodes) {
          nodeSelect.empty();

          // Separate deployed and undeployed nodes
          const deployedNodes = nodes.filter(
            (node) => node.status === "deployed"
          );
          const undeployedNodes = nodes.filter(
            (node) => node.status === "not_deployed"
          );

          if (deployedNodes.length === 0) {
            if (nodes.length === 0) {
              // No nodes at all
              nodeSelect.append(
                '<option value="">No available nodes - please create and deploy first</option>'
              );

              addMessageToUI(
                "info",
                `
üöÄ Welcome to Dev Copilot!

Your AI-powered development assistant is ready to help with coding, debugging, and Node-RED development tasks.

**Quick Setup Guide:**

1Ô∏è‚É£ **Create Node**: Drag "dev copilot" from the "AI dev copilot" category to your canvas

2Ô∏è‚É£ **Configure**: Double-click the node to set up:
   ‚Ä¢ Choose Provider: OpenAI / Google / DeepSeek
   ‚Ä¢ Enter your API key securely
   ‚Ä¢ Select model (e.g., gpt-4, gemini-2.5-pro)
   ‚Ä¢ Adjust Temperature (0.1 for coding) & Token limits

3Ô∏è‚É£ **Deploy**: Click the red "Deploy" button

4Ô∏è‚É£ **Select Node**: Choose your deployed node from the dropdown above

**üí° Pro Tips:**
‚Ä¢ For enhanced capabilities, install our MCP server: \`@supcon-international/node-red-mcp-server\`
‚Ä¢ Use Temperature 0.1-0.3 for precise coding assistance  
‚Ä¢ Set Tool Call Limit to 10-15 for complex multi-step tasks

Ready to dev smarter? Let's chat! üéØ
              `
              );
            } else {
              // Has nodes but all undeployed
              nodeSelect.append(
                '<option value="">All nodes undeployed - please click deploy button</option>'
              );

              addMessageToUI(
                "warning",
                `
‚ö†Ô∏è **Deployment Required**

Found ${undeployedNodes.length} undeployed nodes:
${undeployedNodes
  .map((n) => `‚Ä¢ ${n.name || "Unnamed"} (${n.provider} ${n.model})`)
  .join("\n")}

**Deployment Steps:**
1Ô∏è‚É£ Verify node configuration (double-click nodes to check)
2Ô∏è‚É£ Click the "Deploy" button (top-right)  
3Ô∏è‚É£ Wait for deployment completion
4Ô∏è‚É£ Refresh this page and reselect nodes

**Troubleshooting:**
‚Ä¢ Ensure API keys are correctly entered
‚Ä¢ Check browser console (F12) for error details
‚Ä¢ Verify model names are valid for your provider
              `
              );
            }
          } else {
            // Has deployed nodes
            nodeSelect.append(
              '<option value="">Please select a Dev Copilot node...</option>'
            );

            // Add deployed nodes
            deployedNodes.forEach(function (node) {
              const displayName = node.name || "Unnamed node";
              const option = $("<option></option>")
                .val(node.id)
                .text(`${displayName} (${node.provider} ${node.model})`);
              nodeSelect.append(option);
            });

            // If there are undeployed nodes, show separator and reminder
            if (undeployedNodes.length > 0) {
              nodeSelect.append(
                `<option disabled>--- Undeployed nodes (${undeployedNodes.length}) ---</option>`
              );
              undeployedNodes.forEach(function (node) {
                const displayName = node.name || "Unnamed node";
                const option = $("<option></option>")
                  .val("")
                  .attr("disabled", true)
                  .text(
                    `‚ùå ${displayName} (${node.provider} ${node.model}) - Needs deployment`
                  );
                nodeSelect.append(option);
              });
            }

            // Smart node selection logic (async)
            (async () => {
              const lastSelectedNodeId = await loadSelectedNode();
              let selectedNodeId = null;
              let selectedNode = null;
              let selectionReason = "";

              // 1. First try to restore previously selected node
              if (lastSelectedNodeId) {
                const foundNode = deployedNodes.find(
                  (node) => node.id === lastSelectedNodeId
                );
                if (foundNode) {
                  selectedNodeId = lastSelectedNodeId;
                  selectedNode = foundNode;
                  selectionReason = "Restored previous selection";
                }
              }

              // 2. If no previous selection or previous node unavailable, select first available node
              if (!selectedNodeId && deployedNodes.length > 0) {
                selectedNodeId = deployedNodes[0].id;
                selectedNode = deployedNodes[0];
                selectionReason =
                  deployedNodes.length === 1
                    ? "Only available node"
                    : "Default first selection";
              }

              // 3. Execute node selection
              if (selectedNodeId && selectedNode) {
                nodeSelect.val(selectedNodeId);
                currentNodeId = selectedNodeId;
                await saveSelectedNode(selectedNodeId);

                // Immediately load global shared message history
                messageHistory = await loadMessageHistory();
                restoreMessagesToUI(messageHistory);

                // Silent recovery: only show simple prompt when no history exists
                if (messageHistory.length === 0) {
                  addMessageToUI(
                    "info",
                    `‚úÖ **${selectionReason}**: ${
                      selectedNode.name || "Unnamed node"
                    } (${selectedNode.provider} ${
                      selectedNode.model
                    })\n\nüí¨ Start chatting!`
                  );
                }
                // If there is history, don't show any prompt messages, let user see chat history directly
              }
            })();

            // Handle case with multiple nodes but auto-selection failed
            if (deployedNodes.length > 1) {
              // If auto-selection failed for some reason, show multi-node prompt
              addMessageToUI(
                "info",
                `
üìã Multiple Nodes Available

Found ${
                  deployedNodes.length
                } deployed nodes. Please select one from the dropdown above to start your AI-powered development session.

${
  undeployedNodes.length > 0
    ? `‚ö†Ô∏è Note: ${undeployedNodes.length} additional nodes need deployment. Deploy them if you want to use different configurations.`
    : ""
}

**Tips for Node Selection:**
‚Ä¢ Different nodes can have different LLM providers and configurations
‚Ä¢ Switch between nodes to compare AI responses
‚Ä¢ Use specialized configurations for different project types
              `
              );
            }
          }
        }).fail(function (xhr, status, error) {
          console.error("‚ùå Failed to load nodes:", { xhr, status, error });
          nodeSelect.empty();
          nodeSelect.append('<option value="">Failed to load nodes</option>');
          addMessageToUI(
            "error",
            `üîå **Connection Issue**

Unable to load available nodes. Please check:

**Immediate Actions:**
‚Ä¢ Refresh the browser page
‚Ä¢ Verify Node-RED is running
‚Ä¢ Check network connectivity

**Technical Details:**
‚Ä¢ Error: ${error || "Unknown error"}
‚Ä¢ Status: ${xhr.status || "N/A"}
‚Ä¢ This usually indicates Node-RED service issues

**Need Help?** Check Node-RED logs for more details.`
          );
        });
      }

      // Event listeners
      sendButton.on("click", function (e) {
        e.preventDefault();
        sendMessage();
      });

      messageInput.on("keypress", function (e) {
        if (e.which === 13 && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });

      nodeSelect.on("change", async function () {
        const newNodeId = $(this).val();

        if (newNodeId !== currentNodeId) {
          // Node switching logic - simplified for global shared history
          currentNodeId = newNodeId;

          if (newNodeId) {
            // Save selected node
            await saveSelectedNode(newNodeId);

            // Load global shared message history (same for all nodes)
            messageHistory = await loadMessageHistory();
            restoreMessagesToUI(messageHistory);
          } else {
            // Clear records when no node selected
            await saveSelectedNode(null);
            messageHistory = [];
            messageContainer.empty();
          }
        }
      });

      // Original page initialization logic has been integrated into loadAvailableNodes, no separate handling needed

      // Initialize clear button event listener
      clearButton.on("click", clearGlobalHistory);

      // Initialize stream mode toggle event listener
      const streamToggle = $("#dev-copilot-stream-toggle");
      const streamStatus = $("#stream-status");

      streamToggle.on("change", function () {
        const isEnabled = $(this).is(":checked");
        if (isEnabled) {
          streamStatus.text("Real-time streaming enabled");
          streamStatus.css("color", "#28a745");
        } else {
          streamStatus.text("Traditional mode enabled");
          streamStatus.css("color", "#6c757d");
        }
      });

      // Initialize send button state
      setSendButtonState("ready");
    }
  })();
</script>
