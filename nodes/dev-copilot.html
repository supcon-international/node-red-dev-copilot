<!-- Dev Copilot Node Configuration Panel -->
<script type="text/javascript">
  RED.nodes.registerType("dev-copilot", {
    category: "AI dev copilot",
    color: "#87CEEB",
    defaults: {
      name: { value: "" },
      provider: { value: "openai", required: true },
      model: { value: "gpt-4", required: true },
      temperature: {
        value: 0.1,
        required: true,
        validate: RED.validators.number(),
      },
      maxTokens: {
        value: 2000,
        required: true,
        validate: RED.validators.number(),
      },
      toolCallLimit: {
        value: 10,
        required: true,
        validate: RED.validators.number(),
      },
      mcpCommand: {
        value: "npx @supcon-international/node-red-mcp-server",
      },
      mcpArgs: { value: "" },
      mcpEnv: { value: "" },
      systemPrompt: { value: "" },
    },
    credentials: {
      apiKey: { type: "password", required: true },
    },
    inputs: 1,
    outputs: 1,
    icon: "font-awesome/fa-robot",
    label: function () {
      return this.name || `${this.provider} ${this.model}`;
    },
    labelStyle: function () {
      return this.name ? "node_label_italic" : "";
    },
    paletteLabel: "dev copilot",
    oneditprepare: function () {
      const providerPlaceholders = {
        openai: "e.g.: gpt-4, gpt-4-turbo, gpt-3.5-turbo, gpt-4o, gpt-4o-mini",
        google: "e.g.: gemini-2.5-pro, gemini-2.5-flash, gemini-pro",
        deepseek: "e.g.: deepseek-chat, deepseek-reasoner",
      };

      function updateModelPlaceholder() {
        const provider = $("#node-input-provider").val();
        const modelInput = $("#node-input-model");

        if (providerPlaceholders[provider]) {
          modelInput.attr("placeholder", providerPlaceholders[provider]);
        }
      }

      // Update model placeholder when provider changes
      $("#node-input-provider").on("change", function () {
        updateModelPlaceholder();
      });

      // Initialize
      updateModelPlaceholder();
    },
  });
</script>

<!-- Node editing panel template -->
<script type="text/html" data-template-name="dev-copilot">
  <div class="form-row">
    <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name" />
  </div>

  <div class="form-row">
    <label for="node-input-provider"
      ><i class="fa fa-cloud"></i> Provider</label
    >
    <select id="node-input-provider">
      <option value="openai">OpenAI</option>
      <option value="google">Google</option>
      <option value="deepseek">DeepSeek</option>
    </select>
  </div>

  <div class="form-row">
    <label for="node-input-model"><i class="fa fa-cog"></i> Model</label>
    <input
      type="text"
      id="node-input-model"
      placeholder="e.g.: gpt-4, gpt-4-turbo, gpt-3.5-turbo, gpt-4o, gpt-4o-mini"
    />
    <div class="form-tips">
      Enter the model name you want to use. Recommended models will be shown
      based on the Provider.
    </div>
  </div>

  <div class="form-row">
    <label for="node-input-temperature"
      ><i class="fa fa-thermometer-half"></i> Temperature</label
    >
    <input
      type="number"
      id="node-input-temperature"
      placeholder="0.1"
      min="0"
      max="2"
      step="0.1"
      style="width: 100px;"
    />
    <div class="form-tips">
      Controls randomness (0.0 = deterministic, 2.0 = very creative). For coding
      tasks, use 0.0-0.3.
    </div>
  </div>

  <div class="form-row">
    <label for="node-input-maxTokens"
      ><i class="fa fa-file-text-o"></i> Max Tokens</label
    >
    <input
      type="number"
      id="node-input-maxTokens"
      placeholder="2000"
      min="100"
      max="8000"
      step="100"
      style="width: 100px;"
    />
    <div class="form-tips">
      Maximum response length. For coding: 1000-2000 for snippets, 3000-4000 for
      complex solutions.
    </div>
  </div>

  <div class="form-row">
    <label for="node-input-toolCallLimit"
      ><i class="fa fa-repeat"></i> Tool Call Limit</label
    >
    <input
      type="number"
      id="node-input-toolCallLimit"
      placeholder="10"
      min="1"
      max="20"
      step="1"
      style="width: 100px;"
    />
    <div class="form-tips">
      Maximum rounds of tool calls to prevent infinite loops. For complex tasks,
      use 8-15. For simple tasks, use 3-5.
    </div>
  </div>

  <div class="form-row">
    <label for="node-input-apiKey"><i class="fa fa-key"></i> API Key</label>
    <input type="password" id="node-input-apiKey" data-nr-credentials="true" />
  </div>

  <div class="form-row">
    <label for="node-input-mcpCommand"
      ><i class="fa fa-terminal"></i> MCP Command</label
    >
    <input
      type="text"
      id="node-input-mcpCommand"
      placeholder="e.g.: npx @supcon-international/node-red-mcp-server"
    />
    <div class="form-tips">
      MCP server startup command (leave empty to not use MCP)
    </div>
  </div>

  <div class="form-row">
    <label for="node-input-mcpArgs"><i class="fa fa-list"></i> Arguments</label>
    <input
      type="text"
      id="node-input-mcpArgs"
      placeholder="e.g.: --port 3000 --verbose"
    />
    <div class="form-tips">
      Optional: command line arguments, separated by spaces
    </div>
  </div>

  <div class="form-row">
    <label for="node-input-mcpEnv"
      ><i class="fa fa-gear"></i> Environment Variables</label
    >
    <input
      type="text"
      id="node-input-mcpEnv"
      placeholder="e.g.: API_KEY=xxx,DEBUG=true"
    />
    <div class="form-tips">
      Optional: environment variables, format: KEY=value, multiple separated by
      commas
    </div>
  </div>

  <div class="form-row">
    <label for="node-input-systemPrompt"
      ><i class="fa fa-comment"></i> System Prompt</label
    >
    <textarea
      id="node-input-systemPrompt"
      rows="4"
      placeholder="You are a helpful Node-RED development assistant."
    ></textarea>
  </div>
</script>

<!-- Node help documentation -->
<script type="text/html" data-help-name="dev-copilot">
  <p>AI Development Copilot node with MCP (Model Context Protocol) support.</p>

  <h3>Configuration</h3>
  <dl class="message-properties">
    <dt>Provider <span class="property-type">string</span></dt>
    <dd>The AI provider to use (OpenAI, Google, DeepSeek)</dd>

    <dt>Model <span class="property-type">string</span></dt>
    <dd>The specific model to use (e.g., gpt-4, gemini-1.5-pro)</dd>

    <dt>Temperature <span class="property-type">number</span></dt>
    <dd>
      Controls randomness (0.0 = deterministic, 2.0 = very creative). For coding
      tasks, recommended range: 0.0-0.3
    </dd>

    <dt>Max Tokens <span class="property-type">number</span></dt>
    <dd>
      Maximum response length. For coding: 1000-2000 for snippets, 3000-4000 for
      complex solutions
    </dd>

    <dt>Tool Call Limit <span class="property-type">number</span></dt>
    <dd>
      Maximum rounds of tool calls to prevent infinite loops. For complex
      multi-step tasks, use 8-15. For simple tasks, use 3-5.
    </dd>

    <dt>API Key <span class="property-type">credentials</span></dt>
    <dd>API key for the selected provider</dd>

    <dt>MCP Server Path <span class="property-type">string</span></dt>
    <dd>Path to the MCP server executable (optional)</dd>

    <dt>MCP Server Args <span class="property-type">string</span></dt>
    <dd>Arguments to pass to the MCP server (optional)</dd>

    <dt>System Prompt <span class="property-type">string</span></dt>
    <dd>System prompt to use for AI interactions</dd>
  </dl>

  <h3>Input</h3>
  <dl class="message-properties">
    <dt>payload <span class="property-type">string | object</span></dt>
    <dd>The user message or query to send to the AI</dd>

    <dt>history <span class="property-type">array</span></dt>
    <dd>Optional conversation history array</dd>
  </dl>

  <h3>Output</h3>
  <dl class="message-properties">
    <dt>payload <span class="property-type">string</span></dt>
    <dd>The AI's response</dd>

    <dt>llm_config <span class="property-type">object</span></dt>
    <dd>Configuration used for this request</dd>

    <dt>mcp_available <span class="property-type">boolean</span></dt>
    <dd>Whether MCP tools are available</dd>

    <dt>mcp_tools <span class="property-type">array</span></dt>
    <dd>Available MCP tools (if MCP is connected)</dd>
  </dl>

  <h3>Details</h3>
  <p>
    This node provides AI assistance for development tasks. It can optionally
    connect to MCP (Model Context Protocol) servers to extend functionality with
    additional tools and resources.
  </p>

  <p>
    The node also registers a sidebar interface for interactive chat
    functionality.
  </p>
</script>

<!-- Sidebar registration script -->
<script type="text/javascript">
  (function () {
    let sidebarRegistered = false;

    function registerDevCopilotSidebar() {
      if (sidebarRegistered) {
        console.log("Dev Copilot sidebar already registered");
        return;
      }

      try {
        // Check if RED object is available
        if (!RED || !RED.sidebar) {
          console.log("RED.sidebar not available yet, will retry...");
          setTimeout(registerDevCopilotSidebar, 500);
          return;
        }

        // Register sidebar tab
        RED.sidebar.addTab({
          id: "dev-copilot-sidebar",
          label: "Dev Copilot",
          name: "Dev Copilot",
          iconClass: "fa fa-rocket",
          content: $('<div id="dev-copilot-content"></div>'),
          toolbar: $('<div id="dev-copilot-toolbar"></div>'),
          enableOnEdit: true,
          onchange: function () {
            loadSidebarContent();
          },
        });

        sidebarRegistered = true;
        console.log("Dev Copilot sidebar registered successfully");

        // Load content immediately
        loadSidebarContent();
      } catch (error) {
        console.error("Failed to register Dev Copilot sidebar:", error);
        // If failed, retry later
        setTimeout(registerDevCopilotSidebar, 1000);
      }
    }

    // Wait for DOM and RED to fully load
    $(document).ready(function () {
      // Delay registration to ensure RED is fully loaded
      setTimeout(registerDevCopilotSidebar, 100);
    });

    // Listen for runtime events as backup
    if (RED && RED.events) {
      RED.events.on("runtime-event", function (event) {
        if (
          event.id === "runtime-state" &&
          event.payload.state === "start" &&
          !sidebarRegistered
        ) {
          registerDevCopilotSidebar();
        }
      });
    }

    function loadSidebarContent() {
      const content = $("#dev-copilot-content");
      if (content.length === 0) {
        console.log("Dev Copilot content div not found, will retry...");
        setTimeout(loadSidebarContent, 500);
        return;
      }

      console.log("Loading Dev Copilot sidebar content...");

      // Load sidebar content
      $.get("/dev-copilot/sidebar")
        .done(function (data) {
          console.log("Dev Copilot sidebar content loaded successfully");
          content.html(data);
          initializeSidebarFunctionality();
        })
        .fail(function (xhr, status, error) {
          console.error("Failed to load Dev Copilot sidebar:", {
            status: xhr.status,
            statusText: xhr.statusText,
            error: error,
          });

          let errorMsg = "Failed to load Dev Copilot sidebar";
          if (xhr.status) {
            errorMsg += " (HTTP " + xhr.status + ")";
          }
          if (error) {
            errorMsg += ": " + error;
          }

          content.html(
            '<div class="red-ui-info-outline"><p>' +
              errorMsg +
              "</p><p>Check browser console for more details.</p></div>"
          );
        });
    }

    function initializeSidebarFunctionality() {
      // Initialize sidebar functionality
      const messageContainer = $("#dev-copilot-messages");
      const messageInput = $("#dev-copilot-input");
      const sendButton = $("#dev-copilot-send");
      const configButton = $("#dev-copilot-config");
      const nodeSelect = $("#dev-copilot-node-select");

      // Message history with localStorage persistence
      let messageHistory = [];
      let currentNodeId = null;

      // Message persistence functionality - Using Node-RED context storage (localfilesystem) instead of localStorage
      const CONTEXT_KEY_PREFIX = "dev-copilot-messages-";
      const SELECTED_NODE_CONTEXT_KEY = "dev-copilot-selected-node";
      const MAX_HISTORY_LENGTH = 50; // Limit each node to save 50 messages

      // Context storage helper functions
      async function getContextData(key, nodeId = null) {
        try {
          const response = await $.ajax({
            url: "/dev-copilot/context/get",
            method: "POST",
            contentType: "application/json",
            data: JSON.stringify({ key, nodeId }),
          });
          return response.success ? response.data : null;
        } catch (error) {
          console.warn("Failed to get context data:", error);
          return null;
        }
      }

      async function setContextData(key, data, nodeId = null) {
        try {
          const response = await $.ajax({
            url: "/dev-copilot/context/set",
            method: "POST",
            contentType: "application/json",
            data: JSON.stringify({ key, data, nodeId }),
          });
          return response.success;
        } catch (error) {
          console.warn("Failed to set context data:", error);
          return false;
        }
      }

      async function deleteContextData(key, nodeId = null) {
        try {
          const response = await $.ajax({
            url: "/dev-copilot/context/delete",
            method: "POST",
            contentType: "application/json",
            data: JSON.stringify({ key, nodeId }),
          });
          return response.success;
        } catch (error) {
          console.warn("Failed to delete context data:", error);
          return false;
        }
      }

      // Load message history from Node-RED context storage for a specific node
      async function loadMessageHistory(nodeId) {
        if (!nodeId) return [];

        try {
          const contextKey = CONTEXT_KEY_PREFIX + nodeId;
          const stored = await getContextData(contextKey, nodeId);

          if (stored && Array.isArray(stored)) {
            console.log(
              `üìñ Loading ${stored.length} message history from Node-RED context storage (node: ${nodeId})`
            );
            return stored;
          }
        } catch (error) {
          console.warn("Failed to load message history:", error);
        }
        return [];
      }

      // Save message history for a specific node to Node-RED context storage
      async function saveMessageHistory(nodeId, history) {
        if (!nodeId || !Array.isArray(history)) return false;

        try {
          const contextKey = CONTEXT_KEY_PREFIX + nodeId;
          // Limit history length to avoid context storage becoming too large
          const trimmedHistory = history.slice(-MAX_HISTORY_LENGTH);

          const success = await setContextData(
            contextKey,
            trimmedHistory,
            nodeId
          );
          if (success) {
            console.log(
              `üíæ Saving ${trimmedHistory.length} messages to Node-RED context storage (node: ${nodeId})`
            );
          }
          return success;
        } catch (error) {
          console.warn("Failed to save message history:", error);
          return false;
        }
      }

      // Clean old message history (keep recently used) - simplified for context
      async function cleanupOldMessageHistory() {
        try {
          console.log("üßπ Context cleanup handled by Node-RED storage system");
          // Note: Node-RED context with localfilesystem handles cleanup automatically
          // Manual cleanup not needed unless storage quota is reached
          return true;
        } catch (error) {
          console.warn("Failed to clean message history:", error);
          return false;
        }
      }

      // Restore messages to UI
      function restoreMessagesToUI(history) {
        messageContainer.empty();

        if (history.length === 0) {
          // Show empty state prompt
          messageContainer.html(
            '<div class="dev-copilot-empty-state">Select a Dev Copilot node and start chatting!<br><small>Ask about Node-RED development questions.</small></div>'
          );
          return;
        }

        history.forEach((msg) => {
          if (msg.role === "user") {
            addMessageToUI("user", msg.content);
          } else if (msg.role === "assistant") {
            addMessageToUI("assistant", msg.content);
          }
        });

        console.log(`üîÑ Restoring ${history.length} message history`);
      }

      // Add message and persist
      async function addMessageAndSave(role, content) {
        messageHistory.push({ role, content });

        // Save immediately to Node-RED context storage
        if (currentNodeId) {
          await saveMessageHistory(currentNodeId, messageHistory);
        }
      }

      // Save selected node ID to Node-RED context storage
      async function saveSelectedNode(nodeId) {
        try {
          const success = await setContextData(
            SELECTED_NODE_CONTEXT_KEY,
            nodeId
          );
          if (success) {
            console.log(
              `üíæ Saving selected node to Node-RED context storage: ${
                nodeId || "null"
              }`
            );
          }
          return success;
        } catch (error) {
          console.warn("Failed to save selected node:", error);
          return false;
        }
      }

      // Load last selected node ID from Node-RED context storage
      async function loadSelectedNode() {
        try {
          const nodeId = await getContextData(SELECTED_NODE_CONTEXT_KEY);
          console.log(
            `üìñ Loading last selected node from Node-RED context storage: ${
              nodeId || "None"
            }`
          );
          return nodeId;
        } catch (error) {
          console.warn("Failed to load selected node:", error);
          return null;
        }
      }

      // Clear current node's history
      async function clearCurrentNodeHistory() {
        if (!currentNodeId) {
          RED.notify("Please select a node first", "warning");
          return;
        }

        if (
          confirm(
            "Are you sure you want to clear all chat history for the current node? This action cannot be undone."
          )
        ) {
          messageHistory = [];
          messageContainer.empty();
          messageContainer.html(
            '<div class="dev-copilot-empty-state">Chat history cleared<br><small>Start a new conversation!</small></div>'
          );

          // Remove from Node-RED context storage
          const contextKey = CONTEXT_KEY_PREFIX + currentNodeId;
          const success = await deleteContextData(contextKey, currentNodeId);
          console.log(
            `üóëÔ∏è Clearing all history for node ${currentNodeId}: ${
              success ? "success" : "failed"
            }`
          );
          RED.notify("Chat history cleared", success ? "success" : "error");
        }
      }

      // Load available nodes
      loadAvailableNodes();

      // Send message
      function sendMessage() {
        const message = messageInput.val().trim();
        if (!message) {
          addMessageToUI("error", "Please enter message content");
          return;
        }

        // Check if a node is selected
        if (!currentNodeId) {
          addMessageToUI(
            "error",
            "Please select a Dev Copilot node first. If no nodes are available, please create and configure nodes in the canvas first."
          );
          return;
        }

        // Add user message to interface and save
        addMessageToUI("user", message);
        addMessageAndSave("user", message); // Use new save function (async)

        // Clear input box
        messageInput.val("");

        // Show loading state
        addMessageToUI("assistant", "Thinking...", true);

        // Send request
        $.ajax({
          url: "/dev-copilot/chat",
          method: "POST",
          contentType: "application/json",
          data: JSON.stringify({
            message: message,
            nodeId: currentNodeId,
            history: messageHistory.slice(-10), // Keep last 10 messages for API call
          }),
          success: function (response) {
            // Remove loading message
            $(".dev-copilot-loading").remove();

            if (response.success) {
              addMessageToUI("assistant", response.response);
              addMessageAndSave("assistant", response.response); // Save AI response (async)
            } else {
              addMessageToUI("error", "Error: " + response.error);
            }
          },
          error: function (xhr) {
            $(".dev-copilot-loading").remove();

            let errorMsg = "Network error";
            try {
              const errorResponse = JSON.parse(xhr.responseText);
              errorMsg = errorResponse.error || errorMsg;
            } catch (e) {
              errorMsg = xhr.responseText || errorMsg;
            }

            addMessageToUI("error", errorMsg);
          },
        });
      }

      // Add message to UI
      function addMessageToUI(type, content, isLoading = false) {
        const messageDiv = $(
          '<div class="dev-copilot-message dev-copilot-' + type + '"></div>'
        );
        if (isLoading) {
          messageDiv.addClass("dev-copilot-loading");
        }

        // Set styles and handle content based on message type
        if (type === "info") {
          messageDiv.css({
            "background-color": "#e3f2fd",
            "border-left": "4px solid #2196f3",
            padding: "12px",
            margin: "8px 0",
            "border-radius": "4px",
            "white-space": "pre-line",
            "font-size": "14px",
            "line-height": "1.4",
          });
        } else if (type === "warning") {
          messageDiv.css({
            "background-color": "#fff3e0",
            "border-left": "4px solid #ff9800",
            padding: "12px",
            margin: "8px 0",
            "border-radius": "4px",
            "white-space": "pre-line",
            "font-size": "14px",
            "line-height": "1.4",
            color: "#e65100",
          });
        } else if (type === "error") {
          messageDiv.css({
            "background-color": "#ffebee",
            "border-left": "4px solid #f44336",
            padding: "12px",
            margin: "8px 0",
            "border-radius": "4px",
            "white-space": "pre-line",
            color: "#c62828",
          });
        } else if (type === "user") {
          messageDiv.css({
            "background-color": "#007acc",
            color: "#ffffff",
            padding: "8px 12px",
            margin: "4px 0",
            "border-radius": "12px",
            "text-align": "right",
            "margin-left": "20%",
            "font-weight": "500",
            "box-shadow": "0 1px 2px rgba(0, 0, 0, 0.1)",
          });
        } else if (type === "assistant") {
          messageDiv.css({
            "background-color": "#f8f9fa",
            color: "#333333",
            padding: "8px 12px",
            margin: "4px 0",
            "border-radius": "12px",
            "margin-right": "20%",
            "white-space": "pre-line",
            border: "1px solid #e9ecef",
            "box-shadow": "0 1px 2px rgba(0, 0, 0, 0.05)",
          });
        }

        messageDiv.text(content);
        messageContainer.append(messageDiv);
        messageContainer.scrollTop(messageContainer[0].scrollHeight);
      }

      // Load available nodes
      function loadAvailableNodes() {
        $.get("/dev-copilot/nodes", function (nodes) {
          console.log("üîç Loading node list:", nodes);
          nodeSelect.empty();

          // Separate deployed and undeployed nodes
          const deployedNodes = nodes.filter(
            (node) => node.status === "deployed"
          );
          const undeployedNodes = nodes.filter(
            (node) => node.status === "not_deployed"
          );

          console.log(
            `üìä Node status statistics: Total ${nodes.length}, Deployed ${deployedNodes.length}, Undeployed ${undeployedNodes.length}`
          );

          if (deployedNodes.length === 0) {
            if (nodes.length === 0) {
              // No nodes at all
              nodeSelect.append(
                '<option value="">No available nodes - please create and deploy first</option>'
              );

              addMessageToUI(
                "info",
                `
  üöÄ Welcome to Dev Copilot!

  Your AI-powered development assistant is ready to help with coding, debugging, and Node-RED development tasks.

  **Quick Setup Guide:**

  1Ô∏è‚É£ **Create Node**: Drag "dev copilot" from the "AI dev copilot" category to your canvas

  2Ô∏è‚É£ **Configure**: Double-click the node to set up:
     ‚Ä¢ Choose Provider: OpenAI / Google / DeepSeek
     ‚Ä¢ Enter your API key securely
     ‚Ä¢ Select model (e.g., gpt-4, gemini-2.5-pro)
     ‚Ä¢ Adjust Temperature (0.1 for coding) & Token limits

  3Ô∏è‚É£ **Deploy**: Click the red "Deploy" button

  4Ô∏è‚É£ **Select Node**: Choose your deployed node from the dropdown above

  **üí° Pro Tips:**
  ‚Ä¢ For enhanced capabilities, install our MCP server: \`@supcon-international/node-red-mcp-server\`
  ‚Ä¢ Use Temperature 0.1-0.3 for precise coding assistance
  ‚Ä¢ Set Tool Call Limit to 10-15 for complex multi-step tasks

  Ready to dev smarter? Let's chat! üéØ
                `
              );
            } else {
              // Has nodes but all undeployed
              nodeSelect.append(
                '<option value="">All nodes undeployed - please click deploy button</option>'
              );

              addMessageToUI(
                "warning",
                `
  ‚ö†Ô∏è **Deployment Required**

  Found ${undeployedNodes.length} undeployed nodes:
  ${undeployedNodes
    .map((n) => `‚Ä¢ ${n.name || "Unnamed"} (${n.provider} ${n.model})`)
    .join("\n")}

  **Deployment Steps:**
  1Ô∏è‚É£ Verify node configuration (double-click nodes to check)
  2Ô∏è‚É£ Click the "Deploy" button (top-right)
  3Ô∏è‚É£ Wait for deployment completion
  4Ô∏è‚É£ Refresh this page and reselect nodes

  **Troubleshooting:**
  ‚Ä¢ Ensure API keys are correctly entered
  ‚Ä¢ Check browser console (F12) for error details
  ‚Ä¢ Verify model names are valid for your provider
                `
              );
            }
          } else {
            // Has deployed nodes
            nodeSelect.append(
              '<option value="">Please select a Dev Copilot node...</option>'
            );

            // Add deployed nodes
            deployedNodes.forEach(function (node) {
              const displayName = node.name || "Unnamed node";
              const option = $("<option></option>")
                .val(node.id)
                .text(`${displayName} (${node.provider} ${node.model})`);
              nodeSelect.append(option);
            });

            // If there are undeployed nodes, show separator and reminder
            if (undeployedNodes.length > 0) {
              nodeSelect.append(
                `<option disabled>--- Undeployed nodes (${undeployedNodes.length}) ---</option>`
              );
              undeployedNodes.forEach(function (node) {
                const displayName = node.name || "Unnamed node";
                const option = $("<option></option>")
                  .val("")
                  .attr("disabled", true)
                  .text(
                    `‚ùå ${displayName} (${node.provider} ${node.model}) - Needs deployment`
                  );
                nodeSelect.append(option);
              });
            }

            // Smart node selection logic (async)
            (async () => {
              const lastSelectedNodeId = await loadSelectedNode();
              let selectedNodeId = null;
              let selectedNode = null;
              let selectionReason = "";

              // 1. First try to restore previously selected node
              if (lastSelectedNodeId) {
                const foundNode = deployedNodes.find(
                  (node) => node.id === lastSelectedNodeId
                );
                if (foundNode) {
                  selectedNodeId = lastSelectedNodeId;
                  selectedNode = foundNode;
                  selectionReason = "Restored previous selection";
                  console.log(
                    `üîÑ Restoring previously selected node: ${selectedNodeId}`
                  );
                } else {
                  console.log(
                    `‚ö†Ô∏è Previously selected node ${lastSelectedNodeId} is no longer available, selecting first available node`
                  );
                }
              }

              // 2. If no previous selection or previous node unavailable, select first available node
              if (!selectedNodeId && deployedNodes.length > 0) {
                selectedNodeId = deployedNodes[0].id;
                selectedNode = deployedNodes[0];
                selectionReason =
                  deployedNodes.length === 1
                    ? "Only available node"
                    : "Default first selection";
                console.log(`üéØ ${selectionReason}: ${selectedNodeId}`);
              }

              // 3. Execute node selection
              if (selectedNodeId && selectedNode) {
                nodeSelect.val(selectedNodeId);
                currentNodeId = selectedNodeId;
                await saveSelectedNode(selectedNodeId);

                // Immediately load message history for this node
                messageHistory = await loadMessageHistory(selectedNodeId);
                restoreMessagesToUI(messageHistory);

                // Silent recovery: only show simple prompt when no history exists
                if (messageHistory.length === 0) {
                  addMessageToUI(
                    "info",
                    `‚úÖ **${selectionReason}**: ${
                      selectedNode.name || "Unnamed node"
                    } (${selectedNode.provider} ${
                      selectedNode.model
                    })\n\nüí¨ Start chatting!`
                  );
                }
                // If there is history, don't show any prompt messages, let user see chat history directly

                console.log(
                  `üéØ Node selection completed: ${selectedNode.name} (${selectedNode.provider} ${selectedNode.model}), history: ${messageHistory.length} messages`
                );
              }
            })();

            // Handle case with multiple nodes but auto-selection failed
            if (deployedNodes.length > 1) {
              // If auto-selection failed for some reason, show multi-node prompt
              addMessageToUI(
                "info",
                `
  üìã Multiple Nodes Available

  Found ${
    deployedNodes.length
  } deployed nodes. Please select one from the dropdown above to start your AI-powered development session.

  ${
    undeployedNodes.length > 0
      ? `‚ö†Ô∏è Note: ${undeployedNodes.length} additional nodes need deployment. Deploy them if you want to use different configurations.`
      : ""
  }

  **Tips for Node Selection:**
  ‚Ä¢ Different nodes can have different LLM providers and configurations
  ‚Ä¢ Switch between nodes to compare AI responses
  ‚Ä¢ Use specialized configurations for different project types
                `
              );
            }
          }
        }).fail(function (xhr, status, error) {
          console.error("‚ùå Failed to load nodes:", { xhr, status, error });
          nodeSelect.empty();
          nodeSelect.append('<option value="">Failed to load nodes</option>');
          addMessageToUI(
            "error",
            `üîå **Connection Issue**

  Unable to load available nodes. Please check:

  **Immediate Actions:**
  ‚Ä¢ Refresh the browser page
  ‚Ä¢ Verify Node-RED is running
  ‚Ä¢ Check network connectivity

  **Technical Details:**
  ‚Ä¢ Error: ${error || "Unknown error"}
  ‚Ä¢ Status: ${xhr.status || "N/A"}
  ‚Ä¢ This usually indicates Node-RED service issues

  **Need Help?** Check Node-RED logs for more details.`
          );
        });
      }

      // Event listeners
      sendButton.on("click", sendMessage);
      messageInput.on("keypress", function (e) {
        if (e.which === 13 && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });

      nodeSelect.on("change", async function () {
        const newNodeId = $(this).val();

        if (newNodeId !== currentNodeId) {
          // Node switching logic
          if (currentNodeId) {
            // Save current node's message history
            await saveMessageHistory(currentNodeId, messageHistory);
          }

          currentNodeId = newNodeId;

          if (newNodeId) {
            // Save selected node
            await saveSelectedNode(newNodeId);

            // Load new node's message history
            messageHistory = await loadMessageHistory(newNodeId);
            restoreMessagesToUI(messageHistory);
            console.log(
              `üîÑ Switched to node ${newNodeId}, loaded ${messageHistory.length} history messages`
            );
          } else {
            // Clear records when no node selected
            await saveSelectedNode(null);
            messageHistory = [];
            messageContainer.empty();
          }
        }
      });

      configButton.on("click", function () {
        RED.notify(
          "Use the node configuration panel to modify settings",
          "info"
        );
      });

      // Original page initialization logic has been integrated into loadAvailableNodes, no separate handling needed

      // Add clear history button
      const clearButton = $(
        '<button class="dev-copilot-clear-btn" title="Clear all chat history for current node">üóëÔ∏è Clear</button>'
      );
      clearButton.on("click", clearCurrentNodeHistory);
      configButton.after(clearButton);
    }
  })();
</script>
